/**
 * Blog Publisher Cron
 *
 * Runs DAILY at 4 AM UTC. Publishes up to 3 blog posts per run.
 * Picks top-priority topics not yet covered, generates full posts
 * via Claude Haiku, saves to AutoBlogPost table.
 *
 * Schedule: 0 4 * * *  (daily at 4 AM UTC)
 * Target: 21 posts/week, 90+ posts/month
 */

import { NextResponse } from "next/server";
import { verifyCronAuth } from "@/lib/cron-auth";
import { logCronExecution } from "@/lib/cron-logger";
import { getTopBlogIdeas } from "@/lib/agents/seo-agent/blog-generator";
import { writeAndPublishPost } from "@/lib/agents/seo-agent/blog-writer";
import { Resend } from "resend";
import { getAdminFromEmail } from "@/lib/email";

export const maxDuration = 300;

const JOB_NAME = "blog-publisher";
const POSTS_PER_RUN = 3;
const DEADLINE_MS = 270_000; // 270s safety margin (maxDuration=300)

const resend = process.env.RESEND_API_KEY
  ? new Resend(process.env.RESEND_API_KEY)
  : null;

export async function GET(request: Request) {
  const startTime = Date.now();

  try {
    const authResult = verifyCronAuth(request);
    if (!authResult.authorized) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    console.log(`[${JOB_NAME}] Starting blog publisher (target: ${POSTS_PER_RUN} posts)...`);

    // Get more ideas than we need, so we can skip collisions
    const ideas = await getTopBlogIdeas(POSTS_PER_RUN * 3);

    if (ideas.length === 0) {
      console.log(`[${JOB_NAME}] No new topics to write about`);
      await logCronExecution({
        jobName: JOB_NAME,
        status: "SUCCESS",
        duration: Date.now() - startTime,
        message: "All topics covered â€” no new posts to generate",
        metadata: { postsPublished: 0, reason: "all_topics_covered" },
      });
      return NextResponse.json({ status: "no_new_topics" });
    }

    // Publish up to POSTS_PER_RUN posts, with time-boxing
    const published: { slug: string; title: string; category: string }[] = [];
    let attempted = 0;

    for (const idea of ideas) {
      if (published.length >= POSTS_PER_RUN) break;
      if (Date.now() - startTime >= DEADLINE_MS) {
        console.log(`[${JOB_NAME}] Time limit approaching, stopping at ${published.length} posts`);
        break;
      }

      attempted++;
      console.log(`[${JOB_NAME}] Generating post ${published.length + 1}/${POSTS_PER_RUN}: ${idea.title}`);

      const slug = await writeAndPublishPost(idea);
      if (slug) {
        published.push({ slug, title: idea.title, category: idea.category });
        console.log(`[${JOB_NAME}] Published: /blog/${slug}`);
      }
    }

    if (published.length === 0) {
      console.log(`[${JOB_NAME}] Failed to publish any posts after ${attempted} attempts`);
      await logCronExecution({
        jobName: JOB_NAME,
        status: "FAILED",
        duration: Date.now() - startTime,
        message: `Generation failed after trying ${attempted} topics`,
        metadata: { postsPublished: 0, reason: "generation_failed", topicsAttempted: attempted },
      });
      return NextResponse.json({ status: "generation_failed" });
    }

    // Send single summary notification email
    if (resend) {
      try {
        const postList = published
          .map((p) => `<li><a href="https://ghostmydata.com/blog/${p.slug}">${p.title}</a> (${p.category})</li>`)
          .join("\n");

        await resend.emails.send({
          from: getAdminFromEmail(),
          to: "rocky@ghostmydata.com",
          subject: `${published.length} New Blog Post${published.length > 1 ? "s" : ""} Published`,
          html: `
            <div style="font-family: sans-serif; max-width: 600px;">
              <h2>${published.length} Blog Post${published.length > 1 ? "s" : ""} Auto-Published</h2>
              <ul>${postList}</ul>
              <p style="color: #666; font-size: 14px;">
                Generated by the blog-publisher cron (${Math.round((Date.now() - startTime) / 1000)}s).
                Review posts and make any edits via the database.
              </p>
              <p style="color: #666; font-size: 14px;">
                Topics remaining in queue: ${ideas.length - published.length}
              </p>
            </div>
          `,
        });
      } catch (emailErr) {
        console.error(`[${JOB_NAME}] Notification email failed:`, emailErr);
      }
    }

    const duration = Date.now() - startTime;
    const isPartial = published.length < POSTS_PER_RUN && ideas.length >= POSTS_PER_RUN;

    await logCronExecution({
      jobName: JOB_NAME,
      status: isPartial ? "PARTIAL" : "SUCCESS",
      duration,
      message: `Published ${published.length}/${POSTS_PER_RUN} posts`,
      metadata: {
        postsPublished: published.length,
        posts: published,
        topicsAttempted: attempted,
        topicsRemaining: ideas.length - published.length,
      },
    });

    return NextResponse.json({
      status: "published",
      postsPublished: published.length,
      posts: published,
      topicsRemaining: ideas.length - published.length,
      duration,
    });
  } catch (error) {
    console.error(`[${JOB_NAME}] Error:`, error);
    await logCronExecution({
      jobName: JOB_NAME,
      status: "FAILED",
      duration: Date.now() - startTime,
      message: error instanceof Error ? error.message : "Unknown error",
    });
    return NextResponse.json(
      { error: "Blog publisher failed" },
      { status: 500 }
    );
  }
}
