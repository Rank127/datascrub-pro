/**
 * Blog Publisher Cron
 *
 * Runs twice per week (Wednesday + Saturday at 4 AM UTC).
 * Picks the top-priority blog topic not yet covered, generates a full post
 * via Claude Haiku, saves it to the AutoBlogPost table, and sends a
 * notification email.
 *
 * Schedule: 0 4 * * 3,6  (Wed + Sat at 4 AM UTC)
 */

import { NextResponse } from "next/server";
import { verifyCronAuth } from "@/lib/cron-auth";
import { logCronExecution } from "@/lib/cron-logger";
import { getTopBlogIdeas } from "@/lib/agents/seo-agent/blog-generator";
import { writeAndPublishPost } from "@/lib/agents/seo-agent/blog-writer";
import { Resend } from "resend";

export const maxDuration = 120;

const JOB_NAME = "blog-publisher";

const resend = process.env.RESEND_API_KEY
  ? new Resend(process.env.RESEND_API_KEY)
  : null;

export async function GET(request: Request) {
  const startTime = Date.now();

  try {
    const authResult = verifyCronAuth(request);
    if (!authResult.authorized) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    console.log(`[${JOB_NAME}] Starting blog publisher...`);

    // Get top topic ideas that haven't been written yet
    const ideas = await getTopBlogIdeas(5);

    if (ideas.length === 0) {
      console.log(`[${JOB_NAME}] No new topics to write about`);
      await logCronExecution({
        jobName: JOB_NAME,
        status: "SUCCESS",
        duration: Date.now() - startTime,
        message: "All topics covered â€” no new posts to generate",
        metadata: { postsPublished: 0, reason: "all_topics_covered" },
      });
      return NextResponse.json({ status: "no_new_topics" });
    }

    // Try the top topic first, fall back to next if slug collision
    let publishedSlug: string | null = null;
    let topicUsed = ideas[0];

    for (const idea of ideas) {
      publishedSlug = await writeAndPublishPost(idea);
      if (publishedSlug) {
        topicUsed = idea;
        break;
      }
    }

    if (!publishedSlug) {
      console.log(`[${JOB_NAME}] Failed to publish any post`);
      await logCronExecution({
        jobName: JOB_NAME,
        status: "FAILED",
        duration: Date.now() - startTime,
        message: `Generation failed after trying ${ideas.length} topics`,
        metadata: { postsPublished: 0, reason: "generation_failed", topicsAttempted: ideas.length },
      });
      return NextResponse.json({ status: "generation_failed" });
    }

    const postUrl = `https://ghostmydata.com/blog/${publishedSlug}`;
    console.log(`[${JOB_NAME}] Published: ${postUrl}`);

    // Send notification email
    if (resend) {
      try {
        await resend.emails.send({
          from: "GhostMyData <notifications@ghostmydata.com>",
          to: "rocky@ghostmydata.com",
          subject: `New Blog Post Published: ${topicUsed.title}`,
          html: `
            <div style="font-family: sans-serif; max-width: 600px;">
              <h2>New Blog Post Auto-Published</h2>
              <p><strong>Title:</strong> ${topicUsed.title}</p>
              <p><strong>Category:</strong> ${topicUsed.category}</p>
              <p><strong>Keywords:</strong> ${topicUsed.keywords.join(", ")}</p>
              <p><strong>URL:</strong> <a href="${postUrl}">${postUrl}</a></p>
              <p style="color: #666; font-size: 14px;">
                Generated by the blog-publisher cron. Review the post and make any edits via the database.
              </p>
            </div>
          `,
        });
      } catch (emailErr) {
        console.error(`[${JOB_NAME}] Notification email failed:`, emailErr);
      }
    }

    const duration = Date.now() - startTime;
    await logCronExecution({
      jobName: JOB_NAME,
      status: "SUCCESS",
      duration,
      message: `Published: ${topicUsed.title}`,
      metadata: {
        postsPublished: 1,
        slug: publishedSlug,
        title: topicUsed.title,
        category: topicUsed.category,
        keywords: topicUsed.keywords,
      },
    });

    return NextResponse.json({
      status: "published",
      slug: publishedSlug,
      title: topicUsed.title,
      url: postUrl,
      duration,
    });
  } catch (error) {
    console.error(`[${JOB_NAME}] Error:`, error);
    await logCronExecution({
      jobName: JOB_NAME,
      status: "FAILED",
      duration: Date.now() - startTime,
      message: error instanceof Error ? error.message : "Unknown error",
    });
    return NextResponse.json(
      { error: "Blog publisher failed" },
      { status: 500 }
    );
  }
}
