/**
 * Strategic Directives — Read/Write/Cache Utility
 *
 * Directives are parameters generated by the weekly Mastermind board meeting.
 * Agents and crons read them to adjust thresholds, batch sizes, and strategies.
 * Every read has a sensible default — if no directive exists, behavior is unchanged.
 */

import { prisma } from "@/lib/db";

// ============================================================================
// TYPES
// ============================================================================

export interface DirectiveInput {
  category: string;
  key: string;
  value: unknown;
  rationale: string;
  advisorSource?: string;
  source: string;
}

export interface MastermindDirectiveOutput {
  category: string;
  key: string;
  value: unknown;
  rationale: string;
  advisorSource?: string;
}

// ============================================================================
// IN-MEMORY CACHE (5-minute TTL)
// ============================================================================

const CACHE_TTL_MS = 5 * 60 * 1000;

interface CacheEntry {
  value: unknown;
  expiresAt: number;
}

const cache = new Map<string, CacheEntry>();

function getCacheKey(key: string): string {
  return `directive:${key}`;
}

function getFromCache<T>(key: string): T | undefined {
  const entry = cache.get(getCacheKey(key));
  if (!entry) return undefined;
  if (Date.now() > entry.expiresAt) {
    cache.delete(getCacheKey(key));
    return undefined;
  }
  return entry.value as T;
}

function setInCache(key: string, value: unknown): void {
  cache.set(getCacheKey(key), {
    value,
    expiresAt: Date.now() + CACHE_TTL_MS,
  });
}

function invalidateCache(key?: string): void {
  if (key) {
    cache.delete(getCacheKey(key));
  } else {
    cache.clear();
  }
}

// ============================================================================
// READ FUNCTIONS
// ============================================================================

/**
 * Read a single directive with typed fallback.
 * Returns defaultValue if directive doesn't exist or DB is unavailable.
 */
export async function getDirective<T>(key: string, defaultValue: T): Promise<T> {
  // Check cache first
  const cached = getFromCache<T>(key);
  if (cached !== undefined) return cached;

  try {
    const directive = await prisma.strategicDirective.findFirst({
      where: { key, isActive: true },
      select: { value: true },
    });

    if (directive?.value !== undefined && directive.value !== null) {
      const value = directive.value as T;
      setInCache(key, value);
      return value;
    }
  } catch (error) {
    console.warn(`[Directives] Failed to read directive "${key}":`, error instanceof Error ? error.message : error);
  }

  return defaultValue;
}

/**
 * Read all active directives for a category (e.g., "removal", "content").
 * Returns a key-value map.
 */
export async function getDirectivesForDomain(category: string): Promise<Record<string, unknown>> {
  try {
    const directives = await prisma.strategicDirective.findMany({
      where: { category, isActive: true },
      select: { key: true, value: true },
    });

    const result: Record<string, unknown> = {};
    for (const d of directives) {
      result[d.key] = d.value;
      setInCache(d.key, d.value);
    }
    return result;
  } catch (error) {
    console.warn(`[Directives] Failed to read directives for "${category}":`, error instanceof Error ? error.message : error);
    return {};
  }
}

// ============================================================================
// WRITE FUNCTIONS
// ============================================================================

/**
 * Write/upsert a single directive.
 */
export async function setDirective(opts: DirectiveInput): Promise<void> {
  try {
    await prisma.strategicDirective.upsert({
      where: {
        category_key: { category: opts.category, key: opts.key },
      },
      update: {
        value: opts.value as Parameters<typeof prisma.strategicDirective.upsert>[0]["update"]["value"],
        rationale: opts.rationale,
        advisorSource: opts.advisorSource || null,
        source: opts.source,
        isActive: true,
      },
      create: {
        category: opts.category,
        key: opts.key,
        value: opts.value as Parameters<typeof prisma.strategicDirective.create>[0]["data"]["value"],
        rationale: opts.rationale,
        advisorSource: opts.advisorSource || null,
        source: opts.source,
        isActive: true,
      },
    });

    // Invalidate cache for this key
    invalidateCache(opts.key);
  } catch (error) {
    console.error(`[Directives] Failed to set directive "${opts.key}":`, error instanceof Error ? error.message : error);
    throw error;
  }
}

/**
 * Bulk-write directives from a mastermind analysis.
 * Returns the number of directives written.
 */
export async function applyMastermindDirectives(
  directives: MastermindDirectiveOutput[],
  source: string = "mastermind-weekly"
): Promise<number> {
  let written = 0;

  for (const d of directives) {
    try {
      await setDirective({
        category: d.category,
        key: d.key,
        value: d.value,
        rationale: d.rationale,
        advisorSource: d.advisorSource,
        source,
      });
      written++;
    } catch (error) {
      console.error(`[Directives] Failed to apply directive "${d.key}":`, error instanceof Error ? error.message : error);
    }
  }

  // Clear full cache after bulk write
  invalidateCache();

  return written;
}
