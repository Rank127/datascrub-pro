/**
 * Strategic Directives — Read/Write/Cache Utility
 *
 * Directives are parameters generated by the weekly Mastermind board meeting.
 * Agents and crons read them to adjust thresholds, batch sizes, and strategies.
 * Every read has a sensible default — if no directive exists, behavior is unchanged.
 */

import { prisma } from "@/lib/db";

// ============================================================================
// TYPES
// ============================================================================

export interface DirectiveInput {
  category: string;
  key: string;
  value: unknown;
  rationale: string;
  advisorSource?: string;
  source: string;
}

export interface MastermindDirectiveOutput {
  category: string;
  key: string;
  value: unknown;
  rationale: string;
  advisorSource?: string;
}

// ============================================================================
// IN-MEMORY CACHE (5-minute TTL)
// ============================================================================

const CACHE_TTL_MS = 5 * 60 * 1000;

interface CacheEntry {
  value: unknown;
  expiresAt: number;
}

const cache = new Map<string, CacheEntry>();

function getCacheKey(key: string): string {
  return `directive:${key}`;
}

function getFromCache<T>(key: string): T | undefined {
  const entry = cache.get(getCacheKey(key));
  if (!entry) return undefined;
  if (Date.now() > entry.expiresAt) {
    cache.delete(getCacheKey(key));
    return undefined;
  }
  return entry.value as T;
}

function setInCache(key: string, value: unknown): void {
  cache.set(getCacheKey(key), {
    value,
    expiresAt: Date.now() + CACHE_TTL_MS,
  });
}

function invalidateCache(key?: string): void {
  if (key) {
    cache.delete(getCacheKey(key));
  } else {
    cache.clear();
  }
}

// ============================================================================
// READ FUNCTIONS
// ============================================================================

/**
 * Read a single directive with typed fallback.
 * Returns defaultValue if directive doesn't exist or DB is unavailable.
 */
export async function getDirective<T>(key: string, defaultValue: T): Promise<T> {
  // Check cache first
  const cached = getFromCache<T>(key);
  if (cached !== undefined) return cached;

  try {
    const directive = await prisma.strategicDirective.findFirst({
      where: { key, isActive: true },
      select: { value: true },
    });

    if (directive?.value !== undefined && directive.value !== null) {
      const value = directive.value as T;
      setInCache(key, value);
      return value;
    }
  } catch (error) {
    console.warn(`[Directives] Failed to read directive "${key}":`, error instanceof Error ? error.message : error);
  }

  return defaultValue;
}

/**
 * Read all active directives for a category (e.g., "removal", "content").
 * Returns a key-value map.
 */
export async function getDirectivesForDomain(category: string): Promise<Record<string, unknown>> {
  try {
    const directives = await prisma.strategicDirective.findMany({
      where: { category, isActive: true },
      select: { key: true, value: true },
    });

    const result: Record<string, unknown> = {};
    for (const d of directives) {
      result[d.key] = d.value;
      setInCache(d.key, d.value);
    }
    return result;
  } catch (error) {
    console.warn(`[Directives] Failed to read directives for "${category}":`, error instanceof Error ? error.message : error);
    return {};
  }
}

// ============================================================================
// FORBIDDEN DIRECTIVES — Keys that agents may NEVER write
// Pricing, plan tiers, and Stripe configuration are admin-only.
// Any attempt to set these is rejected with a logged warning.
// ============================================================================

const FORBIDDEN_DIRECTIVE_PREFIXES = [
  "pricing_",       // e.g. pricing_pro_monthly, pricing_enterprise_yearly
  "price_",         // e.g. price_override, price_discount
  "stripe_",        // e.g. stripe_price_id, stripe_coupon
  "plan_price",     // e.g. plan_price_pro, plan_price_enterprise
  "discount_",      // e.g. discount_percentage, discount_code
  "coupon_",        // e.g. coupon_create, coupon_apply
  "trial_",         // e.g. trial_days, trial_extend
] as const;

const FORBIDDEN_DIRECTIVE_KEYS = new Set([
  "pro_monthly_price",
  "pro_yearly_price",
  "enterprise_monthly_price",
  "enterprise_yearly_price",
  "free_tier_limit",
  "free_removal_limit",
  "plan_pricing",
  "stripe_price_ids",
  "billing_price_override",
  "billing_plan_change",
  "billing_discount",
  "billing_coupon",
  "billing_trial_extend",
]);

function isDirectiveForbidden(key: string): boolean {
  if (FORBIDDEN_DIRECTIVE_KEYS.has(key)) return true;
  return FORBIDDEN_DIRECTIVE_PREFIXES.some((prefix) => key.startsWith(prefix));
}

// ============================================================================
// DIRECTIVE BOUNDS — Prevent destructive values from board meetings
// ============================================================================

const DIRECTIVE_BOUNDS: Record<string, { min: number; max: number }> = {
  removal_rate_per_broker: { min: 5, max: 200 },
  removal_batch_pending: { min: 50, max: 5000 },
  removal_batch_retries: { min: 10, max: 1000 },
  removal_anomaly_multiplier: { min: 0.1, max: 2.0 },
  content_target_wordcount: { min: 300, max: 5000 },
  content_target_readability: { min: 30, max: 90 },
  seo_alert_threshold: { min: 20, max: 95 },
  seo_keyword_relevance_min: { min: 20, max: 95 },
  support_batch_size: { min: 5, max: 100 },
  billing_churn_risk_threshold: { min: 0.1, max: 0.95 },
  growth_upsell_confidence_min: { min: 0.3, max: 0.95 },
};

function clampDirectiveValue(key: string, value: unknown): unknown {
  const bounds = DIRECTIVE_BOUNDS[key];
  if (!bounds || typeof value !== "number") return value;

  const clamped = Math.max(bounds.min, Math.min(bounds.max, value));
  if (clamped !== value) {
    console.warn(
      `[Directives] CLAMPED "${key}": ${value} → ${clamped} (bounds: ${bounds.min}–${bounds.max})`
    );
  }
  return clamped;
}

// ============================================================================
// WRITE FUNCTIONS
// ============================================================================

/**
 * Write/upsert a single directive.
 */
export async function setDirective(opts: DirectiveInput): Promise<void> {
  // HARD GUARD: Pricing directives are NEVER writable by agents or board meetings.
  // Pricing changes require manual admin action via Stripe dashboard.
  if (isDirectiveForbidden(opts.key)) {
    console.error(
      `[Directives] BLOCKED: Attempted to set forbidden directive "${opts.key}" from source "${opts.source}". ` +
      `Pricing, plan tiers, and Stripe configuration can only be changed manually by an admin.`
    );
    return; // Silently reject — do not throw (callers should not break)
  }

  try {
    await prisma.strategicDirective.upsert({
      where: {
        category_key: { category: opts.category, key: opts.key },
      },
      update: {
        value: opts.value as Parameters<typeof prisma.strategicDirective.upsert>[0]["update"]["value"],
        rationale: opts.rationale,
        advisorSource: opts.advisorSource || null,
        source: opts.source,
        isActive: true,
      },
      create: {
        category: opts.category,
        key: opts.key,
        value: opts.value as Parameters<typeof prisma.strategicDirective.create>[0]["data"]["value"],
        rationale: opts.rationale,
        advisorSource: opts.advisorSource || null,
        source: opts.source,
        isActive: true,
      },
    });

    // Invalidate cache for this key
    invalidateCache(opts.key);
  } catch (error) {
    console.error(`[Directives] Failed to set directive "${opts.key}":`, error instanceof Error ? error.message : error);
    throw error;
  }
}

/**
 * Bulk-write directives from a mastermind analysis.
 * Returns the number of directives written.
 */
export async function applyMastermindDirectives(
  directives: MastermindDirectiveOutput[],
  source: string = "mastermind-weekly"
): Promise<number> {
  let written = 0;

  for (const d of directives) {
    // Skip forbidden pricing directives — setDirective also checks, but log at bulk level too
    if (isDirectiveForbidden(d.key)) {
      console.warn(`[Directives] SKIPPED forbidden directive "${d.key}" in bulk apply from "${source}"`);
      continue;
    }

    try {
      const clampedValue = clampDirectiveValue(d.key, d.value);
      await setDirective({
        category: d.category,
        key: d.key,
        value: clampedValue,
        rationale: d.rationale,
        advisorSource: d.advisorSource,
        source,
      });
      written++;
    } catch (error) {
      console.error(`[Directives] Failed to apply directive "${d.key}":`, error instanceof Error ? error.message : error);
    }
  }

  // Clear full cache after bulk write
  invalidateCache();

  return written;
}
